# Gathering statistical properties with TLA+

## The specification

See the `queues.tla` and `queues.cfg`.

### Testing multiple configurations

This specififcation can be configured to explore multiple configurations:
- the number of apps
- the number of queues
- different algorithms

For example, the following config has 56 different initial states, each corresponding to a unique combo of app count, queue count and algorithm (there are 4).

```
CONSTANTS MinAppCount = 2
          MaxAppCount = 15
          QueueCount = 10
```

The init formula for this is:

```
\E app_count \in MinAppCount..MaxAppCount :
    \E algo \in Algorithms :
        LET the_apps   == 1..app_count
            the_queues == 1..QueueCount
        IN ...
```

### Writing to CSV

The following creates the CSV file with the column names.

```
ASSUME
  IOExec(
      <<"bash", "-c", "echo \"Traces,Length,Rounds,QueueReleases,Algorithm,Scenario,QueueCount,AppCount\" > " \o CSVFile>>
      ).exitValue = 0 \* Fail fast if CSVFile was not created.
```

`CSVFile` is a constant from the cfg file.

You can record statistics in variables or counters. The benefit of counters is that it doesn't add to the state space. Counters are identifed by an integer.


```
queue_releases_ctr == 0
rounds_ctr == 1

IncrementReleaseCount(a, release_count) ==
   TLCSet(queue_releases_ctr, TLCGet(queue_releases_ctr) + release_count)


SetRound(round) ==
   IF round > TLCGet(rounds_ctr)
   THEN TLCSet(rounds_ctr, round)
   ELSE TRUE
```

To write a line to the CSV:

```
CSVWrite("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s,%7$s,%8$s",
               <<TLCGet("stats").traces,
                 TLCGet("level"),
                 TLCGet(rounds_ctr),
                 TLCGet(queue_releases_ctr),
                 algorithm,
                 Scenario,
                 Cardinality(queues),
                 Cardinality(apps)>>, CSVFile)
```

You can control when to trigger writing to CSV. In the case of this spec it is when the group of applications have reached balance. The `RecordStats` formula is set as an invariant and evaluated in each state. Once balance is reached, the `CSVWrite` function is executed.

### Clearing counters

You must make sure that counters are cleared at the end of a trace. This spec does it when it writes the results to CSV. If you don't properly clear the counters, then one run will pollute the results of another.

## Running it

Set the number of workers according to your hardware. I personally like to record the output to both std out and a file.

```
tlc -generate -workers 1 -depth 1000 -deadlock queues.tla | tee some_file.log
```

Stop it once you have enough runs. The number of runs depends on the number of initial states. I typically ensure 1000-10000 runs per combo (if there is some variance).

### Gotchas

- Always use `generate` not `simulate`. Otherwise, the distribution of existential quantifiers will not be uniform.
- Always set the `-depth` argument to a level much higher than the number of steps you expect TLC to reach. Else it will skew the statistics. Set an invariant to check that TLC doesn't reach that limit `TLCGet("level") < 999`.
- Don't set any temporal properties when running it in `generare` mode, as it will skew results.

## Visualizing results

This I'll leave to the reader. Out of custom and laziness I tend to stick to ggplot2 with R. But there are plenty of Python data viz libraries. See the R notebook `queues.Rmd`.

My R notebook needs percentiles. This is calculated with the following Python script (just set the CSV file to the source data file generated by TLC):

```
python3 calculate_percentiles.py -g Algorithm,Scenario,QueueCount,AppCount -v Rounds -c tla_results.csv
```